<!--
 * @Descripttion: 
 * @Author: YourSongsAreSoGood
 * @Date: 2020-11-20 23:36:30
 * @LastEditTime: 2020-11-21 11:42:20
-->
>## day01 原理和数据基本类型
    编译：就是将.java 文件翻译成 .class文件（字节码文件）  
    运行：将.class文件交给JVM运行  
    
    8个基本数据类型 byte int short long boolean float double char

>## day02 数据类型转换
    数据转换   int + double = double
    强制转换
    ASCII码
    运算符      算术运算符  赋值运算符  比较运算符  逻辑运算符  三元运算符

    方法（函数）

    JShell脚本：编写代码较少的时候，不愿编写类，main方法采用这个方式  
    在dos命令行直接输入 jShell 命令，退出 /exit

    += 符号扩展
```java
    public static void main(String[] args) {
    short s = 1;
    s += 1;           //编译没有问题，会执行强制转换
    System.out.println(s);
    }
```

>## day03 流程控制语句
    流程控制  顺序结构
    判断语句  if else
    选择语句  switch  default
    循环语句  for(;;)  while()  do {}while();
    跳出语句  break  continue

>## day04 IDEA、方法
    IDEA由java语言编写  
    快捷键  alt+enter 自动修正代码，导入包  
    ctrl+alt+l 格式化代码  
    方法定义格式：
``` java
    public static void 方法名称() {
        方法体
    }
```

    调用格式：方法名称();

    注意事项：
        1. 方法定义的先后顺序无所谓。
        2. 方法定义必须是挨着的，不能在一个方法的内部定义另外一个方法。
        3. 方法定义之后，自己不会执行的；如果希望执行，一定要进行方法的调用。

    方法其实就是若干语句的功能集合,好比是一个工厂。
        蒙牛工厂     原料：奶牛、饲料、水
                   产出物：奶制品
        钢铁工厂     原料：铁矿石、煤炭
                   产出物：钢铁建材
    
        参数（原料）：就是进入方法的数据。
        返回值（产出物）：就是从方法中出来的数据。
    
    定义方法的完整格式：
    
        修饰符 返回值类型 方法名称(参数类型 参数名称, ...) {
            方法体
            return 返回值;
        }
    
        修饰符：现阶段的固定写法，public static
        返回值类型：也就是方法最终产生的数据结果是什么类型
        方法名称：方法的名字，规则和变量一样，小驼峰
        
            * 名称只能由字母、数字、下划线、$符号组成
            * 不能以数字开头
            * 名称中不能使用Java中的关键字
            * 吉纳爵不允许出现中文及拼音命名
    
        参数类型：进入方法的数据是什么类型
        参数名称：进入方法的数据对应的变量名称      PS：参数如果有多个，使用逗号进行分隔
        方法体：方法需要做的事情，若干行代码
        return：两个作用，第一停止当前方法，第二将后面的返回值还给调用处
        返回值：也就是方法执行后最终产生的数据结果

        注意：return后面的“返回值”，必须和方法名称前面的“返回值类型”，保持对应。

    定义一个两个int数字相加的方法。三要素：
        返回值类型：int
        方法名称：sum
        参数列表：int a, int b

    方法的三种调用格式。
        1. 单独调用：方法名称(参数);
        2. 打印调用：System.out.println(方法名称(参数));
        3. 赋值调用：数据类型 变量名称 = 方法名称(参数);

        注意：此前学习的方法，返回值类型固定写为void，这种方法只能够单独调用，不能进行打印调用或者赋值调用。

>## day05 数组
    一、数组定义和访问

        容器：将多个数据存储到一起，每个数据称为该容器的元素

        数组的定义：
            int[] arr=new int[3];
            int[] arr=new int[]{1,2,3,4,5};
            int[] arr={1,2,3,4,5};
    
        数组的长度:  arr.length

    二、数组原理内存图
    
        程序在内存中才能运行，运行完毕后会释放内存
        方法区：存储可以运行的class文件
        堆内存：存储对象或者数组，new创建的，都存储在堆内存
        方法栈：方法运行时使用的内存，比如main方法运行，进入方法栈中执行

    三、数组的常见操作
    
        一个方法可以有0、1、多个参数；但是只能有0或者1个返回值，不能有多个返回值。
        
        如果希望一个方法当中产生了多个结果数据进行返回，怎么办？
        解决方案：使用一个数组作为返回值类型即可。

        任何数据类型都能作为方法的参数类型，或者返回值类型。
        
            数组作为方法的参数，传递进去的其实是数组的地址值。
            数组作为方法的返回值，返回的其实也是数组的地址值。

>## day06 类与对象、封装、构造方法

    一、 面向对象的思想
          类：一组相关属性和行为的集合        
        属性：事物的状态信息    
        行为：该事物能做什么
        对象：一类事物的具体体现
        
        栈   堆   方法区

        方法运行结束，会出栈

        两个对象指向同一个堆空间中的类，相当于引用，两者都可以修改类中的变量

    二、 封装
        private     this

        构造方法
            修饰符 构造方法名 （参数列表）{
                ***//方法体
            }

>## day07 Scanner类、Random类、ArrayList类
    一、API
        学会使用Java API文档的使用
[jdk-11中文api修订版.chm下载](https://github.com/Your-songs-are-so-good/Codehomework/blob/master/Study_Java/jdk-11%E4%B8%AD%E6%96%87api%E4%BF%AE%E8%AE%A2%E7%89%88.chm)

    二、Scanner类
    
        操作过程
            1.导包
            2.创建
                // 备注：System.in代表从键盘进行输入
                Scanner sc = new Scanner(System.in);
    
            3.使用
    
                sc.next()   输入字符串    sc.nextInt()  将字符串转换成整型

        匿名对象

            创建对象的标准格式: 类名称 对象名 = new 类名称();
    
            匿名对象就是只有右边的对象，没有左边的名字和赋值运算符。  
            格式: new 类名称();
    
            注意事项：匿名对象只能使用唯一的一次，下次再用不得不再创建一个新对象。
            使用建议：如果确定有一个对象只需要使用唯一的一次，就可以用匿名对象。
    
            // 匿名对象
            new Person().name = "赵又廷";
            new Person().showName(); // 我叫：null
    
            匿名对象传参

    三、Random使用步骤

        Random.nextInt(int n);
        在 0（包括）和指定值（不包括）之间均匀分布的 int 值。


    四、ArrayList类

        数组的长度不可以发生改变，但是ArrayList集合的长度是可以随意变化的。

        对于ArrayList来说，有一个尖括号<E>代表泛型。
            泛型：也就是装在集合当中的所有元素，全都是统一的什么类型。
            注意：泛型只能是引用类型，不能是基本类型。

        注意事项：
        对于ArrayList集合来说，直接打印得到的不是地址值，而是内容。
        如果内容是空，得到的是空的中括号：[]

        // 备注：从JDK 1.7+开始，右侧的尖括号内部可以不写内容，但是<>本身还是要写的。

        常用方法
```java
    add();   
    get();  
    remove();
    size();
```

        错误写法！泛型只能是引用类型，不能是基本类型
            //ArrayList<int> listB = new ArrayList<>();

        如果希望向集合ArrayList当中存储基本类型数据，必须使用基本类型对应的“包装类”。

            基本类型    包装类（引用类型，包装类都位于java.lang包下）
            byte        Byte
            short       Short
            int         Integer     【特殊】
            long        Long
            float       Float
            double      Double
            char        Character   【特殊】
            boolean     Boolean

>## day08 String类、static关键字、Arrays类、Math类
    一、String类
        API当中说：Java 程序中的所有字符串字面值（如 "abc" ）都作为此类的实例实现。
        其实就是说：程序当中所有的双引号字符串，都是String类的对象。（就算没有new，也照样是。）

        字符串的特点：
            1. 字符串的内容永不可变。【重点】
            2. 正是因为字符串不可改变，所以字符串是可以共享使用的。
            3. 字符串效果上相当于是char[]字符数组，但是底层原理是byte[]字节数组。

        创建字符串的常见3+1种方式。
            三种构造方法：
```java
            public String();                    //创建一个空白字符串，不含有任何内容。
            public String(char[] array);        //根据字符数组的内容，来创建对应的字符串。
            public String(byte[] array);        //根据字节数组的内容，来创建对应的字符串。
```
            一种直接创建：
```java
            String str = "Hello";               //右边直接用双引号
```

            注意：直接写上双引号，就是字符串对象。
********************************************************************************************
        字符串常量池：程序当中直接写上的双引号字符串，就在字符串常量池中（在堆中）。

        对于基本类型来说，== 是进行数值的比较。
        对于引用类型来说，== 是进行【地址值】的比较。

        如果确实需要字符串的内容比较，可以使用两个方法：

```java
        public boolean equals(Object obj);    //参数可以是任何对象，只有参数是一个字符串并且内容相同的才会给true；否则返回false。
        
        注意事项：
            1. 任何对象都能用Object进行接收。
            2. equals方法具有对称性，也就是a.equals(b)和b.equals(a)效果一样。
            3. 如果比较双方一个常量一个变量，推荐把常量字符串写在前面。
            推荐："abc".equals(str)    
            不推荐：str.equals("abc")  str=null;发生问题
    
        public boolean equalsIgnoreCase(String str);    //忽略大小写，进行内容比较。
```
********************************************************************************************
        String当中与获取相关的常用方法有：
```java
        public int length();                            //获取字符串当中含有的字符个数，拿到字符串长度。
        public String concat(String str);               //将当前字符串和参数字符串拼接成为返回值新的字符串。
        public char charAt(int index);                  //获取指定索引位置的单个字符。（索引从0开始。）
        public int indexOf(String str);                 //查找参数字符串在本字符串当中首次出现的索引位置，如果没有返回-1值。
```
********************************************************************************************
        字符串的截取方法：
```java
        public String substring(int index);          //截取从参数位置一直到字符串末尾，返回新字符串。
        public String substring(int begin, int end); //截取从begin开始，一直到end结束，中间的字符串。
        
        备注：[begin,end)，包含左边，不包含右边。
```
********************************************************************************************
        String当中与转换相关的常用方法有：
```java
        public char[] toCharArray()                 //将当前字符串拆分成为字符数组作为返回值。
        public byte[] getBytes()                    //获得当前字符串底层的字节数组。
        public String replace(CharSequence oldString, CharSequence newString)       //将所有出现的老字符串替换成为新的字符串，返回替换之后的结果新字符串。
        
        备注：CharSequence意思就是说可以接受字符串类型。
```
********************************************************************************************
        分割字符串的方法：
```java
        public String[] split(String regex)         //按照参数的规则，将字符串切分成为若干部分。

        注意事项：
        split方法的参数其实是一个“正则表达式”，今后学习。
        今天要注意：如果按照英文句点“.”进行切分，必须写"\\."（两个反斜杠）
```
********************************************************************************************
    二、Static关键字
        一旦使用static修饰成员方法，那么这就成为了静态方法。静态方法不属于对象，而是属于类的。
            如果没有static关键字，那么必须首先创建对象，然后通过对象才能使用它。
            如果有了static关键字，那么不需要创建对象，直接就能通过类名称来使用它。

        无论是成员变量，还是成员方法。如果有了static，都推荐使用类名称进行调用。
            静态变量：类名称.静态变量
            静态方法：类名称.静态方法()

        注意事项：
            1. 静态不能直接访问非静态。
                原因：因为在内存当中是【先】有的静态内容，【后】有的非静态内容。  “先人不知道后人，但是后人知道先人。”
            2. 静态方法当中不能用this。
                原因：this代表当前对象，通过谁调用的方法，谁就是当前对象。
||内存||
|:-:|:-:|:-:|
| 栈  | 堆  |方法区（静态区的位置）|

        静态代码块的格式是：
```java
        public class 类名称 {
            static {
                // 静态代码块的内容
            }
        }
```

        特点：
            当第一次用到本类时，静态代码块执行唯一的一次。
            静态内容总是优先于非静态，所以静态代码块比构造方法先执行。

        静态代码块的典型用途：
            用来一次性地对静态成员变量进行赋值。

    三、Arrays类
        java.util.Arrays是一个与数组相关的工具类，里面提供了大量静态方法，用来实现数组常见的操作。
```java
        public static String toString(数组);            //将参数数组变成字符串（按照默认格式：[元素1, 元素2, 元素3...]）
        public static void sort(数组);                  //按照默认升序（从小到大）对数组的元素进行排序。
    
    备注：
        1. 如果是数值，sort默认按照升序从小到大
        2. 如果是字符串，sort默认按照字母升序
        3. 如果是自定义的类型，那么这个自定义的类需要有Comparable或者Comparator接口的支持。（今后学习）
```

    四、Math类
        java.util.Math类是数学相关的工具类，里面提供了大量的静态方法，完成与数学运算相关的操作。
```java
        public static double abs(double num);        //获取绝对值。有多种重载。
        public static double ceil(double num);       //向上（正方向）取整。
        public static double floor(double num);      //向下取整。 
        public static long round(double num);        //四舍五入。
```
        Math.PI代表近似的圆周率常量（double）。
>## day09 继承、super、this、抽象类
    一、继承
        继承解决的问题是：共性抽取
        父类，超类，基类
        子类，派生类    extends

        定义子类格式：
            public class 子类名称 extends 父类名称{
                //****
            
            }

        在父子类的继承关系当中，如果成员变量重名，则创建子类对象时，访问有两种方式：
            1. 直接通过子类对象访问成员变量：等号左边是谁，就优先用谁，没有则向上找。
            2. 间接通过成员方法访问成员变量：该方法属于谁，就优先用谁，没有则向上找。
********************************************************************************************
        局部变量：         直接写成员变量名
        本类的成员变量：    this.成员变量名
        父类的成员变量：    super.成员变量名
********************************************************************************************
        在父子类的继承关系当中，创建子类对象，访问成员方法的规则：创建的对象是谁，就优先用谁，如果没有则向上找。
        
        注意事项：无论是成员方法还是成员变量，如果没有都是向上找父类，绝对不会向下找子类的。

        重写（Override）
        概念：在继承关系当中，方法的名称一样，参数列表也一样。
        
            重写（Override）：方法的名称一样，参数列表【也一样】。覆盖、覆写。
            重载（Overload）：方法的名称一样，参数列表【不一样】。
            
            方法的覆盖重写特点：创建的是子类对象，则优先用子类方法。
********************************************************************************************
        方法覆盖重写的注意事项：

            1. 必须保证父子类之间方法的名称相同，参数列表也相同。
            
                @Override：写在方法前面，用来检测是不是有效的正确覆盖重写。
                这个注解就算不写，只要满足要求，也是正确的方法覆盖重写。

            2. 子类方法的返回值必须【小于等于】父类方法的返回值范围。
                
                小扩展提示：java.lang.Object类是所有类的公共最高父类（祖宗类），java.lang.String就是Object的子类。

            3. 子类方法的权限必须【大于等于】父类方法的权限修饰符。
            
                小扩展提示：public > protected > (default) > private
                备注：(default)不是关键字default，而是什么都不写，留空。
********************************************************************************************
        继承关系中，父子类构造方法的访问特点：

            1. 子类构造方法当中有一个默认隐含的“super()”调用，所以一定是先调用的父类构造，后执行的子类构造。
            2. 子类构造可以通过super关键字来调用父类重载构造。
            3. super的父类构造调用，必须是子类构造方法的第一个语句。不能一个子类构造调用多次super构造。
        
        总结：子类必须调用父类构造方法，不写则赠送super()；写了则用写的指定的super调用，super只能有一个，还必须是第一个。
********************************************************************************************
        super关键字的用法有三种：
            1. 在子类的成员方法中，访问父类的成员变量。
            2. 在子类的成员方法中，访问父类的成员方法。
            3. 在子类的构造方法中，访问父类的构造方法。
********************************************************************************************
        super关键字用来访问父类内容，而this关键字用来访问本类内容。用法也有三种：

            1. 在本类的成员方法中，访问本类的成员变量。
            2. 在本类的成员方法中，访问本类的另一个成员方法。
            3. 在本类的构造方法中，访问本类的另一个构造方法。
            
            在第三种用法当中要注意：
                A. this(...)调用也必须是构造方法的第一个语句，唯一一个。
                B. super和this两种构造调用，不能同时使用。
********************************************************************************************
```java
        public void show() {
            int num = 30;
            System.out.println(num); // 30
            System.out.println(this.num); // 20
            System.out.println(super.num); // 10
        }
```
********************************************************************************************
        Java继承的三个特点：
            1. Java语言是单继承的，一个类的直接父类只能有一个
            2. Java语言可以多级继承
            3. 一个类的直接父类是唯一的，但是一个父类可以有多个子类
********************************************************************************************

    二、抽象类
        抽象方法：就是加上abstract关键字，然后去掉大括号，直接分号结束。
        抽象类：抽象方法所在的类，必须是抽象类才行。在class之前写上abstract即可。
        
        如何使用抽象类和抽象方法：
            1. 不能直接创建new抽象类对象。
            2. 必须用一个子类来继承抽象父类。
            3. 子类必须覆盖重写抽象父类当中所有的抽象方法。
                    覆盖重写（实现）：子类去掉抽象方法的abstract关键字，然后补上方法体大括号。
            4. 创建子类对象进行使用。
********************************************************************************************
        一个抽象类不一定含有抽象方法，只要保证抽象方法所在的类是抽象类，即可。
        
        这样没有抽象方法的抽象类，也不能直接创建对象，在一些特殊场景下有用途。

>## day10 接口多态
    一、接口
        接口就是多个类的公共规范。
        接口是一种引用数据类型，最重要的内容就是其中的：抽象方法。

        如何定义一个接口的格式：
        
            public interface 接口名称 {
                // 接口内容
            }

        备注：换成了关键字interface之后，编译生成的字节码文件仍然是：.java --> .class。

        如果是Java 7，那么接口中可以包含的内容有：
            1. 常量
            2. 抽象方法
        
        如果是Java 8，还可以额外包含有：
            3. 默认方法
            4. 静态方法
        
        如果是Java 9，还可以额外包含有：
            5. 私有方法

        接口使用步骤：
            1. 接口不能直接使用，必须有一个“实现类”来“实现”该接口。
                格式：
                public class 实现类名称 implements 接口名称 {
                    // ...
                }
                
            2. 接口的实现类必须覆盖重写（实现）接口中所有的抽象方法。
                实现：去掉abstract关键字，加上方法体大括号。

            3. 创建实现类的对象，进行使用。

            注意事项：如果实现类并没有覆盖重写接口中所有的抽象方法，那么这个实现类自己就必须是抽象类。
********************************************************************************************
        在任何版本的Java中，接口都能定义抽象方法。
            格式：  public abstract 返回值类型 方法名称(参数列表);
            
            注意事项：
                1. 接口当中的抽象方法，修饰符必须是两个固定的关键字：public abstract
                2. 这两个关键字修饰符，可以选择性地省略。
                3. 方法的三要素，可以随意定义。
********************************************************************************************
        从Java 8开始，接口里允许定义默认方法。
            格式：
                public default 返回值类型 方法名称(参数列表) {
                    方法体
                }

            备注：接口当中的默认方法，可以解决接口升级的问题。
                1. 接口的默认方法，可以通过接口实现类对象，直接调用。
                2. 接口的默认方法，也可以被接口实现类进行覆盖重写。
********************************************************************************************
        从Java 8开始，接口当中允许定义静态方法。
            格式：
                public static 返回值类型 方法名称(参数列表) {
                    方法体
                }

            提示：就是将abstract或者default换成static即可，带上方法体。

            注意事项：不能通过接口实现类的对象来调用接口当中的静态方法。
            正确用法：通过接口名称，直接调用其中的静态方法。
            格式：  接口名称.静态方法名(参数);
********************************************************************************************
        问题描述：
            我们需要抽取一个共有方法，用来解决两个默认方法之间重复代码的问题。
            但是这个共有方法不应该让实现类使用，应该是私有化的。
        
        解决方案：
            从Java 9开始，接口当中允许定义私有方法。
                1. 普通私有方法，解决多个默认方法之间重复代码问题
                    格式：
                    private 返回值类型 方法名称(参数列表) {
                        方法体
                    }
            
                2. 静态私有方法，解决多个静态方法之间重复代码问题
                    格式：
                    private static 返回值类型 方法名称(参数列表) {
                        方法体
                    }
********************************************************************************************
        接口当中也可以定义“成员变量”，但是必须使用public static final三个关键字进行修饰。
        从效果上看，这其实就是接口的【常量】。
        
        格式：public static final 数据类型 常量名称 = 数据值;
        备注：一旦使用final关键字进行修饰，说明不可改变。

        注意事项：
            1. 接口当中的常量，可以省略public static final，注意：不写也照样是这样。
            2. 接口当中的常量，必须进行赋值；不能不赋值。
            3. 接口中常量的名称，使用完全大写的字母，用下划线进行分隔。（推荐命名规则）
********************************************************************************************
>##### 接口小结

        在java版本中，接口的内容可以有：
            1. 成员变量其实是变量，格式：
                public static final 数据类型 常量名称=数据值；
                
                注意：常量必须进行赋值，而且一旦赋值不能改变，常量名称完全大写，用下划线进行分割。
            2. 接口中最重要的就是抽象方法，格式：
                public abstract 返回值类型 方法名称（参数列表）；
            
                注意：实现类必须要覆盖重写接口类所有的抽象方法，除非实现类是抽象类
            
            3. 从Java 8 开始，接口里允许定义默认方法，格式：
                public default 返回值类型 方法名称（参数列表）{ 方法体 }
            
                注意：默认方法也可以被覆盖重写
            4. 从Java 8 开始，接口里允许定义静态方法，格式：
                public static 返回值类型 方法名称（参数列表）{ 方法体 }
            
                注意：应该通过接口名称进行调用，不能通过实现类对象调用接口静态方法
            5. 从Java 9 开始，接口里允许定义私有方法，格式：
                普通私有方法：private 返回值类型 方法名称（参数列表）{方法体}
                静态私有方法：private static 返回值类型 方法名称（参数列表）{方法体}
                注意：private 的方法只有接口自己才能调用，不能被实现类或别人使用

        使用接口的时候，需要注意：
        
            1. 接口是没有静态代码块或者构造方法的。
            2. 一个类的直接父类是唯一的，但是一个类可以同时实现多个接口。
                格式：
                    public class MyInterfaceImpl implements MyInterfaceA, MyInterfaceB {
                        // 覆盖重写所有抽象方法
                    }
                
            3. 如果实现类所实现的多个接口当中，存在重复的抽象方法，那么只需要覆盖重写一次即可。
            4. 如果实现类没有覆盖重写所有接口当中的所有抽象方法，那么实现类就必须是一个抽象类。
            5. 如果实现类所实现的多个接口当中，存在重复的默认方法，那么实现类一定要对冲突的默认方法进行覆盖重写。
            6. 一个类如果直接父类当中的方法，和接口当中的默认方法产生了冲突，优先用父类当中的方法。
********************************************************************************************
********************************************************************************************
        1. 类与类之间是单继承的。直接父类只有一个。
        2. 类与接口之间是多实现的。一个类可以实现多个接口。
        3. 接口与接口之间是多继承的。
        
        注意事项：
            1. 多个父接口当中的抽象方法如果重复，没关系。
            2. 多个父接口当中的默认方法如果重复，那么子接口必须进行默认方法的覆盖重写，【而且带着default关键字】。
********************************************************************************************
    二、多态

        代码当中体现多态性，其实就是一句话：父类引用指向子类对象。
        
        格式：  父类名称 对象名 = new 子类名称();
        或者：  接口名称 对象名 = new 实现类名称();
********************************************************************************************
        访问成员变量的两种方式：
            1. 直接通过对象名称访问成员变量：看等号左边是谁，优先用谁，没有则向上找。
            2. 间接通过成员方法访问成员变量：看该方法属于谁，优先用谁，没有则向上找。
        
        在多态的代码当中，成员方法的访问规则是：
            看new的是谁，就优先用谁，没有则向上找。
        
        口诀：编译看左边，运行看右边。
        
        对比一下：
            成员变量：编译看左边，运行还看左边。
            成员方法：编译看左边，运行看右边。
********************************************************************************************
        1.  对象的向上转型，其实就是多态的写法    格式：父类名称 对象名 =new 子类名称();   向上转型一定是安全的
        2.  对象的向下转型，其实是一个还原的动作  格式：子类名称 对象名=(子类名称)父类对象

        向上转型一定是安全的，没有问题的，正确的。但是也有一个弊端：对象一旦向上转型为父类，那么就无法调用子类原本特有的内容。
        
        如何才能知道一个父类引用的对象，本来是什么子类？
        解决方案：用对象的向下转型【还原】。
        
            格式：  对象 instanceof 类名称
                这将会得到一个boolean值结果，也就是判断前面的对象能不能当做后面类型的实例。
```java
            // 如果希望掉用子类特有方法，需要向下转型
            // 判断一下父类引用animal本来是不是Dog
            if (animal instanceof Dog) {
                Dog dog = (Dog) animal;
                dog.watchHouse();
            }
            // 判断一下animal本来是不是Cat
            if (animal instanceof Cat) {
                Cat cat = (Cat) animal;
                cat.catchMouse();
            }
```
>## day11 final、权限、内部类、引用类型
    一、final关键字
        
        final关键字代表最终、不可改变的。

        常见四种用法：
            1. 可以用来修饰一个类
            2. 可以用来修饰一个方法
            3. 还可以用来修饰一个局部变量
            4. 还可以用来修饰一个成员变量

        当final关键字用来修饰一个类的时候，格式：
            public final class 类名称 {
                // ...
            }
    
            含义：当前这个类不能有任何的子类。（太监类）
            注意：一个类如果是final的，那么其中所有的成员方法都无法进行覆盖重写（因为没儿子。）

        当final关键字用来修饰一个方法的时候，这个方法就是最终方法，也就是不能被覆盖重写。
            格式：
            修饰符 final 返回值类型 方法名称(参数列表) {
                // 方法体
            }

        注意事项：
        
            对于类、方法来说，abstract关键字和final关键字不能同时使用，因为矛盾。
    
            一旦使用final用来修饰局部变量，那么这个变量就不能进行更改。
    
                final int num2 = 200;
        
                //正确写法！只要保证有唯一一次赋值即可
                final int num3;
                num3 = 30;
        
                // 对于基本类型来说，不可变说的是变量当中的数据不可改变
                // 对于引用类型来说，不可变说的是变量当中的地址值不可改变
    
            对于成员变量来说，如果使用final关键字修饰，那么这个变量也照样是不可变。
    
                1. 由于成员变量具有默认值，所以用了final之后必须手动赋值，不会再给默认值了。
                2. 对于final的成员变量，要么使用直接赋值，要么通过构造方法赋值。二者选其一。
                3. 必须保证类当中所有重载的构造方法，都最终会对final的成员变量进行赋值。

********************************************************************************************


    二、权限修饰符

        Java中有四种权限修饰符：
                                public  >   protected   >   (default)   >   private
            同一个类（我自己）        YES         YES             YES             YES
            同一个包（我邻居）        YES         YES             YES             NO
            不同包子类（我儿子）       YES         YES             NO              NO
            不同包非子类（陌生人）      YES         NO              NO              NO
        
        注意事项：(default)并不是关键字“default”，而是根本不写。
********************************************************************************************
********************************************************************************************
    三、内部类
        如果一个事物的内部包含另一个事物，那么这就是一个类内部包含另一个类。
        例如：身体和心脏的关系。又如：汽车和发动机的关系。
        
        分类：
            1. 成员内部类
            2. 局部内部类（包含匿名内部类）
        
        成员内部类的定义格式：
            修饰符 class 外部类名称 {
                修饰符 class 内部类名称 {
                    // ...
                }
                // ...
            }

            注意：内用外，随意访问；外用内，需要内部类对象。


        如何使用成员内部类？有两种方式：
            1. 间接方式：在外部类的方法当中，使用内部类；然后main只是调用外部类的方法。
            2. 直接方式，公式：
                类名称 对象名 = new 类名称();   【外部类名称.内部类名称 对象名 = new 外部类名称().new 内部类名称();】
                
                Body.Heart heart = new Body().new Heart();
    
                // 如果出现了重名现象，那么格式是：外部类名称.this.外部类成员变量名
                System.out.println(num); // 局部变量，就近原则
                System.out.println(this.num); // 内部类的成员变量
                System.out.println(Outer.this.num); // 外部类的成员变量
***************************************************************
        如果一个类是定义在一个方法内部的，那么这就是一个局部内部类。
        “局部”：只有当前所属的方法才能使用它，出了这个方法外面就不能用了。

        定义格式：
            修饰符 class 外部类名称 {
                修饰符 返回值类型 外部类方法名称(参数列表) {
                    class 局部内部类名称 {
                        // ...
                    }
                }
            }
>##### 小节 类的权限修饰符
        public > protected > (default) > private
        定义一个类的时候，权限修饰符规则：
            1. 外部类：public / (default)
            2. 成员内部类：public / protected / (default) / private
            3. 局部内部类：什么都不能写
*************************************************************
        局部内部类，如果希望访问所在方法的局部变量，那么这个局部变量必须是【有效final的】。
        
        备注：从Java 8+开始，只要局部变量事实不变，那么final关键字可以省略。
        
        原因：
            1. new出来的对象在堆内存当中。
            2. 局部变量是跟着方法走的，在栈内存当中。
            3. 方法运行结束之后，立刻出栈，局部变量就会立刻消失。
            4. 但是new出来的对象会在堆当中持续存在，直到垃圾回收消失。
*************************************************************
        如果接口的实现类（或者是父类的子类）只需要使用唯一的一次，那么这种情况下就可以省略掉该类的定义，而改为使用【匿名内部类】。
        
        匿名内部类的定义格式：
            接口名称 对象名 = new 接口名称() {
                // 覆盖重写所有抽象方法
            };
        
        对格式“new 接口名称() {...}”进行解析：
            1. new代表创建对象的动作
            2. 接口名称就是匿名内部类需要实现哪个接口
            3. {...}这才是匿名内部类的内容
        
        另外还要注意几点问题：
            1. 匿名内部类，在【创建对象】的时候，只能使用唯一一次。
            如果希望多次创建对象，而且类的内容一样的话，那么就需要使用单独定义的实现类了。
            
            2. 匿名对象，在【调用方法】的时候，只能调用唯一一次。
            如果希望同一个对象，调用多次方法，那么必须给对象起个名字。

            3. 匿名内部类是省略了【实现类/子类名称】，但是匿名对象是省略了【对象名称】
            强调：匿名内部类和匿名对象不是一回事！！！

********************************************************************************************
    四、引用类型用方法总结

        1. 类作为成员变量类型
        2. 接口作为成员变量类型
        3. 接口作为方法的参数和或返回值